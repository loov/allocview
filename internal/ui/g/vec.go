// generated by vec.gen
// DO NOT EDIT

package g

// Vector is a 2 element vector
type Vector struct{ X, Y float32 }

var (
	V0 = Vector{}
	V1 = Vector{1, 1}
)

func V(X, Y float32) Vector {
	return Vector{X: X, Y: Y}
}

// Add does a component wise a + b
func (a Vector) Add(b Vector) Vector {
	return Vector{X: a.X + b.X, Y: a.Y + b.Y}
}

// Sub does a component wise a - b
func (a Vector) Sub(b Vector) Vector {
	return Vector{X: a.X - b.X, Y: a.Y - b.Y}
}

// Mul does a component wise a * b
func (a Vector) Mul(b Vector) Vector {
	return Vector{X: a.X * b.X, Y: a.Y * b.Y}
}

// Div does a component wise a / b
func (a Vector) Div(b Vector) Vector {
	return Vector{X: a.X / b.X, Y: a.Y / b.Y}
}

// Scale scales each component by s
func (a Vector) Scale(s float32) Vector {
	return Vector{X: a.X * s, Y: a.Y * s}
}

// Dot returns the dot product of a and b
func (a Vector) Dot(b Vector) float32 {
	return (a.X*b.X + a.Y*b.Y)
}

// Len returns vector length
func (a Vector) Len() float32 {
	return Sqrt(a.X*a.X + a.Y*a.Y)
}

// Len2 returns vector length squared
func (a Vector) Len2() float32 {
	return (a.X*a.X + a.Y*a.Y)
}

// Normal returns normalized vector
func (a Vector) Normal() Vector {
	s := 1.0 / a.Len()
	return Vector{X: a.X * s, Y: a.Y * s}
}

// Min does an element wise min
func (a Vector) Min(b Vector) Vector {
	return Vector{X: Min(a.X, b.X), Y: Min(a.Y, b.Y)}
}

// Max does an element wise max
func (a Vector) Max(b Vector) Vector {
	return Vector{X: Max(a.X, b.X), Y: Max(a.Y, b.Y)}
}

// Eq returns whether a == b
func (a Vector) Eq(b Vector) bool {
	return (a.X == b.X && a.Y == b.Y)
}

// Lt returns whether a < b
func (a Vector) Lt(b Vector) bool {
	return (a.X < b.X && a.Y < b.Y)
}

// Le returns whether a <= b
func (a Vector) Le(b Vector) bool {
	return (a.X <= b.X && a.Y <= b.Y)
}

// Gt returns whether a > b
func (a Vector) Gt(b Vector) bool {
	return (a.X > b.X && a.Y > b.Y)
}

// Ge returns whether a >= b
func (a Vector) Ge(b Vector) bool {
	return (a.X >= b.X && a.Y >= b.Y)
}

// EqAlmost returns whether Abs(a - b) < eps
func (a Vector) EqAlmost(b Vector, eps float32) bool {
	return (Abs(a.X-b.X) < eps && Abs(a.Y-b.Y) < eps)
}

// Lerp returns linearly interpolated vector
func (a Vector) Lerp(b Vector, p float32) Vector {
	return Vector{X: Lerp(a.X, b.X, p), Y: Lerp(a.Y, b.Y, p)}
}

// Lerp returns linearly interpolated vector
func (a Vector) LerpClamp(b Vector, p float32) Vector {
	if p < 0 {
		return a
	} else if p > 1 {
		return b
	}
	return Vector{X: Lerp(a.X, b.X, p), Y: Lerp(a.Y, b.Y, p)}
}

// Clamp returns vector inside min, max
func (a Vector) Clamp(min, max Vector) Vector {
	return Vector{X: Clamp(a.X, min.X, max.X), Y: Clamp(a.Y, min.Y, max.Y)}
}

// Clamp01 returns vector inside 0, 1
func (a Vector) Clamp01() Vector {
	return Vector{X: Clamp01(a.X), Y: Clamp01(a.Y)}
}

// Clamp1 returns vector inside -1, 1
func (a Vector) Clamp1() Vector {
	return Vector{X: Clamp1(a.X), Y: Clamp1(a.Y)}
}

// ClampUnit returns scaled vector where Len <= 1
func (a Vector) ClampUnit() Vector {
	m := a.Len()
	if m < 1 {
		return a
	}
	return a.Scale(1 / m)
}

// Slice returns all components as a slice
func (a Vector) Slice() []float32 {
	return []float32{a.X, a.Y}
}

// Float2 returns two first components
func (a Vector) FloatXY() [2]float32 { return [2]float32{a.X, a.Y} }

type Rect struct{ Min, Max Vector }

// Add returns Rect translated by p
func (r Rect) Add(p Vector) Rect {
	return Rect{Min: r.Min.Add(p), Max: r.Max.Add(p)}
}

// Canon returns canonical version of r
func (r Rect) Canon() Rect {
	return Rect{Min: r.Min.Min(r.Max), Max: r.Min.Max(r.Max)}
}

// Contains returns whether p is fully contained in rect
func (r Rect) Contains(p Vector) bool {
	return r.Min.Lt(p) && p.Lt(r.Max)
}

// Inflate increases size by 2*p
func (r Rect) Inflate(p Vector) Rect {
	return Rect{Min: r.Min.Sub(p), Max: r.Max.Add(p)}
}

// Deflate shrinks size by 2*p
func (r Rect) Deflate(p Vector) Rect {
	return Rect{Min: r.Min.Add(p), Max: r.Max.Sub(p)}
}

// Union returns smallest bounding box that contains both a and b
func (a Rect) Union(b Rect) Rect {
	a, b = a.Canon(), b.Canon()
	return Rect{Min: a.Min.Min(b.Min), Max: a.Max.Max(b.Max)}
}

// Size returns Max - Min
func (r Rect) Size() Vector { return r.Max.Sub(r.Min) }
