// +build ignore

package main

import (
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"strings"
	"text/template"
)

func main() {
	type Spec struct {
		N    int
		Svec string
		Vec  string
		Rect string
		Comp []string
	}

	var specs = []Spec{
		{2, "V", "Vector", "Rect", []string{"X", "Y"}},
	}

	var buf bytes.Buffer
	fmt.Fprintf(&buf, "// generated by vec.gen\n")
	fmt.Fprintf(&buf, "// DO NOT EDIT\n\n")

	fmt.Fprintf(&buf, "package g\n\n")
	for _, spec := range specs {
		T.Execute(&buf, spec)
	}

	fmted, err := format.Source(buf.Bytes())
	if err != nil {
		for no, line := range strings.Split(buf.String(), "\n") {
			fmt.Printf("%3d %s\n", no, strings.TrimRight(line, "\r\n"))
		}
		panic(err)
	}

	err = ioutil.WriteFile("vec.go", fmted, 0755)
	if err != nil {
		panic(err)
	}
}

var funcs = template.FuncMap{
	"join": strings.Join,
}

var T = template.Must(template.New("").Funcs(funcs).Parse(`
// {{.Vec}} is a {{.N}} element vector
type {{.Vec}} struct { {{ join .Comp ", " }} float32 }

var (
	Z{{.N}} = {{.Vec}}{}
	I{{.N}} = {{.Vec}}{
		{{- range .Comp -}}
		1,
		{{- end -}}
	}
)

func {{.Svec}}({{ join .Comp ", " }} float32 ) {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: {{.}},
		{{- end -}}
	}
}

// Add does a component wise a + b
func (a {{.Vec}}) Add(b {{.Vec}}) {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: a.{{.}} + b.{{.}},
		{{- end -}}
	}
}

// Sub does a component wise a - b
func (a {{.Vec}}) Sub(b {{.Vec}}) {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: a.{{.}} - b.{{.}},
		{{- end -}}
	}
}

// Mul does a component wise a * b
func (a {{.Vec}}) Mul(b {{.Vec}}) {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: a.{{.}} * b.{{.}},
		{{- end -}}
	}
}

// Div does a component wise a / b
func (a {{.Vec}}) Div(b {{.Vec}}) {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: a.{{.}} / b.{{.}},
		{{- end -}}
	}
}

// Scale scales each component by s
func (a {{.Vec}}) Scale(s float32) {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: a.{{.}} * s,
		{{- end -}}
	}
}

// Dot returns the dot product of a and b
func (a {{.Vec}}) Dot(b {{.Vec}}) float32 {
	return (
		{{- range $i, $v := .Comp -}}
		{{ if ne $i 0 }} + {{- end -}}
		a.{{.}} * b.{{.}}
		{{- end -}}
	)
}

// Len returns vector length
func (a {{.Vec}}) Len() float32 {
	return Sqrt(
		{{- range $i, $v := .Comp -}}
		{{ if ne $i 0 }} + {{- end -}}
		a.{{.}} * a.{{.}}
		{{- end -}}
	)
}

// Len2 returns vector length squared
func (a {{.Vec}}) Len2() float32 {
	return (
		{{- range $i, $v := .Comp -}}
		{{ if ne $i 0 }} + {{- end -}}
		a.{{.}} * a.{{.}}
		{{- end -}}
	)
}

// Normal returns normalized vector
func (a {{.Vec}}) Normal() {{.Vec}} {
	s := 1.0 / a.Len()
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: a.{{.}} * s,
		{{- end -}}
	}
}

// Min does an element wise min
func (a {{.Vec}}) Min(b {{.Vec}}) {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: Min(a.{{.}}, b.{{.}}),
		{{- end -}}
	}
}

// Max does an element wise max
func (a {{.Vec}}) Max(b {{.Vec}}) {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: Max(a.{{.}}, b.{{.}}),
		{{- end -}}
	}
}


// Eq returns whether a == b
func (a {{.Vec}}) Eq(b {{.Vec}}) bool {
	return (
		{{- range $i, $v := .Comp -}}
		{{ if ne $i 0 }} && {{- end -}}
		a.{{.}} == b.{{.}}
		{{- end -}}
	)
}

// Lt returns whether a < b
func (a {{.Vec}}) Lt(b {{.Vec}}) bool {
	return (
		{{- range $i, $v := .Comp -}}
		{{ if ne $i 0 }} && {{- end -}}
		a.{{.}} < b.{{.}}
		{{- end -}}
	)
}

// Le returns whether a <= b
func (a {{.Vec}}) Le(b {{.Vec}}) bool {
	return (
		{{- range $i, $v := .Comp -}}
		{{ if ne $i 0 }} && {{- end -}}
		a.{{.}} <= b.{{.}}
		{{- end -}}
	)
}

// Gt returns whether a > b
func (a {{.Vec}}) Gt(b {{.Vec}}) bool {
	return (
		{{- range $i, $v := .Comp -}}
		{{ if ne $i 0 }} && {{- end -}}
		a.{{.}} > b.{{.}}
		{{- end -}}
	)
}

// Ge returns whether a >= b
func (a {{.Vec}}) Ge(b {{.Vec}}) bool {
	return (
		{{- range $i, $v := .Comp -}}
		{{ if ne $i 0 }} && {{- end -}}
		a.{{.}} >= b.{{.}}
		{{- end -}}
	)
}

// EqAlmost returns whether Abs(a - b) < eps
func (a {{.Vec}}) EqAlmost(b {{.Vec}}, eps float32) bool {
	return (
		{{- range $i, $v := .Comp -}}
		{{ if ne $i 0 }} && {{- end -}}
		Abs(a.{{.}} - b.{{.}}) < eps
		{{- end -}}
	)
}

// Lerp returns linearly interpolated vector
func (a {{.Vec}}) Lerp(b {{.Vec}}, p float32) {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: Lerp(a.{{.}}, b.{{.}}, p),
		{{- end -}}
	}
}

// Lerp returns linearly interpolated vector
func (a {{.Vec}}) LerpClamp(b {{.Vec}}, p float32) {{.Vec}} {
	if p < 0 {
		return a
	} else if p > 1 {
		return b
	}
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: Lerp(a.{{.}}, b.{{.}}, p),
		{{- end -}}
	}
}


// Clamp returns vector inside min, max
func (a {{.Vec}}) Clamp(min, max {{.Vec}}) {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: Clamp(a.{{.}}, min.{{.}}, max.{{.}}),
		{{- end -}}
	}
}

// Clamp01 returns vector inside 0, 1
func (a {{.Vec}}) Clamp01() {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: Clamp01(a.{{.}}),
		{{- end -}}
	}
}

// Clamp1 returns vector inside -1, 1
func (a {{.Vec}}) Clamp1() {{.Vec}} {
	return {{.Vec}}{
		{{- range .Comp -}}
		{{.}}: Clamp1(a.{{.}}),
		{{- end -}}
	}
}

// ClampUnit returns scaled vector where Len <= 1
func (a {{.Vec}}) ClampUnit() {{.Vec}} {
	m := a.Len()
	if m < 1 { 
		return a
	}
	return a.Scale(1/m)
}

// Slice returns all components as a slice
func (a {{.Vec}}) Slice() []float32 {
	return []float32{
		{{- range $i, $v := .Comp -}}
		a.{{.}},
		{{- end -}}
	}
}
{{ if ge .N 2 -}}
// Float2 returns two first components
func (a {{.Vec}}) FloatXY() [2]float32 { return [2]float32{a.X, a.Y} }
{{- end }}
{{ if ge .N 3 -}}
// Float3 returns three first components
func (a {{.Vec}}) FloatXYZ() [3]float32 { return [3]float32{a.X, a.Y, a.Z} }
{{- end }}
{{- if ge .N 4 -}}
// Float4 returns four first components
func (a {{.Vec}}) FloatXYZW() [4]float32 { return [4]float32{a.X, a.Y, a.Z, a.W} }
{{- end }}


{{ if ge .N 2 -}}
// XY returns Vec2{X, Y}
func (a {{.Vec}}) XY() Vec2 { return Vec2{a.X, a.Y} }
{{- end }}
{{ if ge .N 3 -}}
// XYZ returns Vec3{X, Y, Z}
func (a {{.Vec}}) XYZ() Vec3 { return Vec3{a.X, a.Y, a.Z} }
{{- end }}
{{ if ge .N 4 -}}
// XYZW returns Vec4{X, Y, Z, W}
func (a {{.Vec}}) XYZW() Vec4 { return Vec4{a.X, a.Y, a.Z, a.W} }
{{- end }}

{{ if ne .Rect "" }}
type {{.Rect}} struct { Min, Max {{.Vec}} }

// Add returns {{.Rect}} translated by p
func (r {{.Rect}}) Add(p {{.Vec}}) {{.Rect}} {
	return {{.Rect}}{Min: r.Min.Add(p), Max: r.Max.Add(p)}
}

// Canon returns canonical version of r
func (r {{.Rect}}) Canon() {{.Rect}} {
	return {{.Rect}}{Min: r.Min.Min(r.Max), Max: r.Min.Max(r.Max)}
}

// Contains returns whether p is fully contained in rect
func (r {{.Rect}}) Contains(p {{.Vec}}) bool {
	return r.Min.Lt(p) && p.Lt(r.Max)
}
// Inflate increases size by 2*p
func (r {{.Rect}}) Inflate(p {{.Vec}}) {{.Rect}} {
	return {{.Rect}}{Min: r.Min.Sub(p), Max: r.Max.Add(p)}
}
// Deflate shrinks size by 2*p
func (r {{.Rect}}) Deflate(p {{.Vec}}) {{.Rect}} {
	return {{.Rect}}{Min: r.Min.Add(p), Max: r.Max.Sub(p)}
}
// Union returns smallest bounding box that contains both a and b
func (a {{.Rect}}) Union(b {{.Rect}}) {{.Rect}} {
	a, b = a.Canon(), b.Canon()
	return {{.Rect}} { Min: a.Min.Min(b.Min), Max: a.Max.Max(b.Max) }
}

// Size returns Max - Min
func (r {{.Rect}}) Size() {{.Vec}} { return r.Max.Sub(r.Min) }
{{ end }}
`))
